import { supabase } from '../lib/supabase';
import { v4 as uuidv4 } from 'uuid';

// No longer needed - display_id is auto-generated by database trigger

// Types
export interface QuoteRequest {
  id: string;
  customer_id: string;
  service_type: string;
  pickup_location: string;
  destination_warehouses: any;
  cargo_ready_date: string;
  total_weight?: number;
  total_volume?: number;
  total_cartons?: number;
  special_requirements?: string;
  status: string;
  created_at?: string;
  updated_at?: string;
}

export interface Quote {
  id: string;
  request_id: string;
  customer_id: string;
  staff_id?: string;
  rate_type?: string;
  freight_cost: number;
  insurance_cost?: number;
  additional_charges?: any;
  total_cost: number;
  valid_until: string;
  status: string;
  per_warehouse_costs?: any;
  commission_rate_per_kg?: number;
  notes?: string;
  created_at?: string;
  updated_at?: string;
}

export interface Shipment {
  id: string;
  quote_id?: string;
  customer_id: string;
  status: string;
  origin: string;
  destination: string;
  cargo_details?: any;
  estimated_weight?: number;
  actual_weight?: number;
  estimated_delivery?: string;
  actual_delivery?: string;
  created_at?: string;
  updated_at?: string;
}

export interface User {
  id: string;
  display_id?: number;
  name: string;
  email: string;
  password_hash?: string;
  company: string;
  role: 'admin' | 'user' | 'staff';
  amazon_seller_id?: string;
  ein_tax_id?: string;
  staff_position?: string;
  created_at?: string;
  updated_at?: string;
}

// Helper function to get next sequence ID
async function getNextSequenceId(type: 'quote' | 'shipment' | 'quote_request'): Promise<string> {
  const { data, error } = await supabase.rpc('increment_sequence', { seq_type: type });
  
  if (error || !data) {
    // Fallback to timestamp-based ID
    const timestamp = Date.now().toString().slice(-5);
    if (type === 'quote') return `Q-${timestamp}`;
    if (type === 'shipment') return `FS-${timestamp}`;
    return `QR-${timestamp}`;
  }
  
  const paddedNumber = data.toString().padStart(5, '0');
  if (type === 'quote') return `Q-${paddedNumber}`;
  if (type === 'shipment') return `FS-${paddedNumber}`;
  return `QR-${paddedNumber}`;
}

// Supabase Service
export const supabaseService = {
  // User methods
  users: {
    async getAll() {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async getById(id: string) {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .eq('id', id)
        .maybeSingle();

      if (error) throw error;
      return data;
    },

    async getByEmail(email: string) {
      const { data, error } = await supabase
        .from('users')
        .select('*')
        .ilike('email', email)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      return data;
    },

    async create(user: Partial<User>) {
      const newUser = {
        ...user,
        id: user.id || `user-${uuidv4()}`
        // display_id will be auto-assigned by database trigger
      };

      const { data, error } = await supabase
        .from('users')
        .insert(newUser)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },

    async update(id: string, updates: Partial<User>) {
      const { data, error } = await supabase
        .from('users')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    }
  },

  // Quote Request methods
  quoteRequests: {
    async getAll() {
      const { data, error } = await supabase
        .from('quote_requests')
        .select('*')
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async getByCustomerId(customerId: string) {
      const { data, error } = await supabase
        .from('quote_requests')
        .select('*')
        .eq('customer_id', customerId)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async getById(id: string) {
      const startTime = Date.now();
      console.log('supabaseService.quoteRequests.getById START:', id, new Date().toISOString());
      
      // Validate ID before making the request
      if (!id || id === 'undefined' || id === 'null') {
        console.warn('Invalid quote request ID provided:', id);
        return null;
      }
      
      console.log('About to query Supabase for quote request');
      const { data, error } = await supabase
        .from('quote_requests')
        .select('*')
        .eq('id', id)
        .single();
      
      console.log('Quote request query completed after:', Date.now() - startTime, 'ms');
      
      if (error) throw error;
      return data;
    },

    async create(request: Partial<QuoteRequest>) {
      // Generate sequential ID
      const requestId = await getNextSequenceId('quote_request');
      
      const newRequest = {
        ...request,
        id: requestId,
        status: request.status || 'Awaiting Quote'
      };

      const { data, error } = await supabase
        .from('quote_requests')
        .insert(newRequest)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },

    async update(id: string, updates: Partial<QuoteRequest>) {
      const { data, error } = await supabase
        .from('quote_requests')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    }
  },

  // Quote methods
  quotes: {
    async getAll() {
      const { data, error } = await supabase
        .from('quotes')
        .select(`
          *,
          quote_requests (
            service_type,
            pickup_location,
            destination_warehouses
          )
        `)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async getByCustomerId(customerId: string) {
      const { data, error } = await supabase
        .from('quotes')
        .select(`
          *,
          quote_requests (
            service_type,
            pickup_location,
            destination_warehouses
          )
        `)
        .eq('customer_id', customerId)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async getById(id: string) {
      // Validate ID before making the request
      if (!id || id === 'undefined' || id === 'null') {
        console.warn('Invalid quote ID provided:', id);
        return null;
      }
      
      const { data, error } = await supabase
        .from('quotes')
        .select(`
          *,
          quote_requests (
            service_type,
            pickup_location,
            destination_warehouses
          )
        `)
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    },

    async create(quote: Partial<Quote>) {
      // Extract the number from the request_id (e.g., QR-00006 -> 00006)
      let quoteId: string;
      if (quote.request_id && quote.request_id.startsWith('QR-')) {
        const requestNumber = quote.request_id.substring(3); // Remove 'QR-' prefix
        quoteId = `Q-${requestNumber}`;
      } else {
        // Fallback to sequence ID if request_id doesn't follow expected format
        quoteId = await getNextSequenceId('quote');
      }
      
      // Ensure all required fields are present and properly formatted
      const newQuote = {
        id: quoteId,
        request_id: quote.request_id,
        customer_id: quote.customer_id,
        staff_id: quote.staff_id || null,
        rate_type: quote.rate_type || 'per-kg',
        freight_cost: quote.freight_cost || 0,
        insurance_cost: quote.insurance_cost || 0,
        additional_charges: quote.additional_charges || null,
        total_cost: quote.total_cost || 0,
        valid_until: quote.valid_until || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        status: quote.status || 'Pending',
        per_warehouse_costs: quote.per_warehouse_costs || null,
        commission_rate_per_kg: quote.commission_rate_per_kg || null,
        notes: quote.notes || null
      };

      console.log('Supabase quote insert:', newQuote);

      const { data, error } = await supabase
        .from('quotes')
        .insert(newQuote)
        .select()
        .single();
      
      if (error) {
        console.error('Supabase quote creation error:', error);
        throw error;
      }
      
      // Update quote request status
      if (quote.request_id) {
        await supabaseService.quoteRequests.update(quote.request_id, {
          status: 'Quoted'
        });
      }
      
      return data;
    },

    async update(id: string, updates: Partial<Quote>) {
      const { data, error } = await supabase
        .from('quotes')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },

    async accept(id: string) {
      // Get quote details with request information
      const quote = await this.getById(id);
      if (!quote) throw new Error('Quote not found');
      
      console.log('Accepting quote:', quote);
      
      // Check if already accepted
      if (quote.status === 'Accepted') {
        console.log('Quote already accepted, checking for existing shipment');
        // Check if shipment already exists
        const existingShipments = await supabaseService.shipments.getByQuoteId(id);
        if (existingShipments && existingShipments.length > 0) {
          console.log('Shipment already exists for this quote');
          return { quote, shipment: existingShipments[0] };
        }
      }
      
      // Update quote status
      await this.update(id, { status: 'Accepted' });
      
      // Get the quote request details if not already loaded
      let quoteRequest = quote.quote_requests;
      if (!quoteRequest && quote.request_id) {
        quoteRequest = await supabaseService.quoteRequests.getById(quote.request_id);
      }
      
      // Extract the number from the quote ID (e.g., Q-00006 -> 00006)
      let shipmentId: string;
      if (id && id.startsWith('Q-')) {
        const quoteNumber = id.substring(2); // Remove 'Q-' prefix
        shipmentId = `FS-${quoteNumber}`;
      } else {
        // Fallback to timestamp-based ID if quote ID doesn't follow expected format
        const timestamp = Date.now().toString().slice(-5);
        shipmentId = `FS-${timestamp}`;
      }
      
      // Prepare destination data
      let destinationData = '';
      if (quoteRequest) {
        if (quoteRequest.destination_warehouses) {
          destinationData = typeof quoteRequest.destination_warehouses === 'string' 
            ? quoteRequest.destination_warehouses 
            : JSON.stringify(quoteRequest.destination_warehouses);
        }
      }
      
      const shipmentData = {
        id: shipmentId,
        quote_id: id,
        customer_id: quote.customer_id,
        status: 'Booking Confirmed',
        origin: quoteRequest?.pickup_location || 'Unknown Origin',
        destination: destinationData || 'Unknown Destination',
        estimated_delivery: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
        cargo_details: quoteRequest?.destination_warehouses || null
      };
      
      console.log('Creating shipment with data:', shipmentData);
      const shipment = await supabaseService.shipments.create(shipmentData);
      
      return { quote, shipment };
    }
  },

  // Shipment methods
  shipments: {
    async getAll() {
      const { data, error } = await supabase
        .from('shipments')
        .select(`
          *,
          quotes (
            total_cost
          )
        `)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async getByCustomerId(customerId: string) {
      const { data, error } = await supabase
        .from('shipments')
        .select(`
          *,
          quotes (
            total_cost
          )
        `)
        .eq('customer_id', customerId)
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async getById(id: string) {
      const startTime = Date.now();
      console.log('supabaseService.getById START at:', new Date().toISOString());
      
      // Validate ID before making the request
      if (!id || id === 'undefined' || id === 'null') {
        console.warn('Invalid shipment ID provided:', id);
        return null;
      }
      
      console.log('About to query Supabase for shipment:', id);
      
      try {
        // Add timeout to prevent hanging
        const queryPromise = supabase
          .from('shipments')
          .select(`
            *,
            quotes (
              total_cost
            ),
            users!customer_id (
              id,
              name,
              email,
              company
            )
          `)
          .eq('id', id)
          .single();
        
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Query timeout after 5 seconds')), 5000)
        );
        
        const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;
        
        console.log('Supabase query completed after:', Date.now() - startTime, 'ms');
        
        if (error) {
          console.error('Error fetching shipment:', error);
          throw error;
        }
        
        console.log('Returning shipment data after:', Date.now() - startTime, 'ms');
        console.log('Shipment documents field:', data?.documents);
        return data;
      } catch (error) {
        console.error('Supabase query failed after:', Date.now() - startTime, 'ms', error);
        throw error;
      }
    },

    async getByQuoteId(quoteId: string) {
      const { data, error } = await supabase
        .from('shipments')
        .select('*')
        .eq('quote_id', quoteId);
      
      if (error) throw error;
      return data;
    },

    async create(shipment: Partial<Shipment>) {
      console.log('Creating shipment in database:', shipment);
      
      const { data, error } = await supabase
        .from('shipments')
        .insert(shipment)
        .select()
        .single();
      
      if (error) {
        console.error('Failed to create shipment:', error);
        throw error;
      }
      
      console.log('Shipment created successfully:', data);
      
      // Create initial tracking event
      await supabaseService.tracking.create({
        id: `TE-${uuidv4()}`,
        shipment_id: data.id,
        date: new Date().toISOString(),
        status: 'Booking Confirmed',
        location: shipment.origin,
        description: 'Shipment booking has been confirmed'
      });
      
      return data;
    },

    async update(id: string, updates: any) {
      console.log('Updating shipment:', id, 'with updates:', updates);

      // Extract only the fields that exist in the database
      const dbUpdates: any = {};

      // Only update fields that exist in the shipments table
      if (updates.status !== undefined) dbUpdates.status = updates.status;
      if (updates.current_location !== undefined) dbUpdates.current_location = updates.current_location;
      if (updates.estimated_delivery !== undefined) dbUpdates.estimated_delivery = updates.estimated_delivery;
      if (updates.actual_delivery !== undefined) dbUpdates.actual_delivery = updates.actual_delivery;
      if (updates.cargo_details !== undefined) dbUpdates.cargo_details = updates.cargo_details;

      // Handle documents separately - save to dedicated documents column
      if (updates.documents !== undefined) {
        dbUpdates.documents = updates.documents;
        console.log('Setting documents in dbUpdates:', dbUpdates.documents);
      }

      // Handle destination updates carefully to preserve all data
      if (updates.destination !== undefined || updates.destinations !== undefined || updates.invoice !== undefined) {
        // First, fetch the current shipment to preserve existing data
        const { data: currentShipment } = await supabase
          .from('shipments')
          .select('destination')
          .eq('id', id)
          .single();
        
        let existingData = {};
        if (currentShipment?.destination) {
          existingData = typeof currentShipment.destination === 'string' 
            ? JSON.parse(currentShipment.destination)
            : currentShipment.destination;
        }
        
        // Preserve existing data
        const preservedInvoice = existingData.invoice || null;
        const preservedDestinations = existingData.destinations || [];
        const preservedMasterCargo = existingData.masterCargo || null;

        // Handle different update scenarios
        if (updates.invoice !== undefined && updates.destinations === undefined && updates.destination === undefined) {
          // Only updating invoice - preserve destinations
          dbUpdates.destination = {
            destinations: preservedDestinations,
            invoice: updates.invoice,
            ...(preservedMasterCargo ? { masterCargo: preservedMasterCargo } : {})
          };
        } else if (updates.destinations !== undefined) {
          // Updating destinations - preserve invoice
          dbUpdates.destination = {
            destinations: updates.destinations,
            invoice: preservedInvoice,
            ...(preservedMasterCargo ? { masterCargo: preservedMasterCargo } : {})
          };
        } else if (updates.destination !== undefined) {
          // If updating the whole destination object, intelligently merge
          const newDestination = typeof updates.destination === 'object' ? updates.destination : {};
          
          // If new destination has invoice but no destinations, preserve existing destinations
          if (newDestination.invoice && !newDestination.destinations) {
            dbUpdates.destination = {
              destinations: preservedDestinations,
              invoice: newDestination.invoice,
              ...(newDestination.masterCargo || preservedMasterCargo ? { masterCargo: newDestination.masterCargo || preservedMasterCargo } : {})
            };
          } else {
            // Otherwise merge everything
            dbUpdates.destination = {
              destinations: newDestination.destinations || preservedDestinations,
              invoice: newDestination.invoice || preservedInvoice,
              ...(newDestination.masterCargo || preservedMasterCargo ? { masterCargo: newDestination.masterCargo || preservedMasterCargo } : {})
            };
          }
        }
      }
      
      console.log('Filtered updates for database:', dbUpdates);
      
      const { data, error } = await supabase
        .from('shipments')
        .update(dbUpdates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) {
        console.error('Error updating shipment:', error);
        throw error;
      }
      
      console.log('Shipment updated successfully:', data);
      console.log('Updated shipment documents:', data?.documents);
      return data;
    }
  },

  // Tracking events
  tracking: {
    async create(event: any) {
      const { data, error } = await supabase
        .from('tracking_events')
        .insert(event)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },

    async getByShipmentId(shipmentId: string) {
      const { data, error } = await supabase
        .from('tracking_events')
        .select('*')
        .eq('shipment_id', shipmentId)
        .order('date', { ascending: false });
      
      if (error) throw error;
      return data;
    }
  },

  // Documents
  documents: {
    async create(document: any) {
      const { data, error } = await supabase
        .from('documents')
        .insert({
          ...document,
          id: document.id || `DOC-${uuidv4()}`
        })
        .select()
        .single();
      
      if (error) throw error;
      return data;
    },

    async getByShipmentId(shipmentId: string) {
      const { data, error } = await supabase
        .from('documents')
        .select('*')
        .eq('shipment_id', shipmentId)
        .order('uploaded_at', { ascending: false });
      
      if (error) throw error;
      return data;
    },

    async delete(id: string) {
      const { error } = await supabase
        .from('documents')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
      return true;
    }
  },

  // Announcements
  announcements: {
    async getActive() {
      const { data, error } = await supabase
        .from('announcements')
        .select(`
          *,
          creator:users!created_by(
            id,
            name,
            email,
            role,
            company
          )
        `)
        .eq('is_active', true)
        .order('created_at', { ascending: false });

      if (error) throw error;
      // Map snake_case to camelCase for frontend compatibility
      return data?.map(ann => ({
        id: ann.id,
        title: ann.title,
        content: ann.content,
        type: ann.type,
        createdBy: ann.created_by,
        creator: ann.creator ? {
          id: ann.creator.id,
          name: ann.creator.name,
          email: ann.creator.email,
          role: ann.creator.role,
          company: ann.creator.company
        } : null,
        isActive: ann.is_active,
        createdAt: ann.created_at,
        updatedAt: ann.updated_at
      }));
    },

    async getAll() {
      const { data, error } = await supabase
        .from('announcements')
        .select(`
          *,
          creator:users!created_by(
            id,
            name,
            email,
            role,
            company
          )
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;
      // Map snake_case to camelCase for frontend compatibility
      return data?.map(ann => ({
        id: ann.id,
        title: ann.title,
        content: ann.content,
        type: ann.type,
        createdBy: ann.created_by,
        creator: ann.creator ? {
          id: ann.creator.id,
          name: ann.creator.name,
          email: ann.creator.email,
          role: ann.creator.role,
          company: ann.creator.company
        } : null,
        isActive: ann.is_active,
        createdAt: ann.created_at,
        updatedAt: ann.updated_at
      }));
    },

    async create(announcement: any) {
      const { data, error } = await supabase
        .from('announcements')
        .insert({
          ...announcement,
          id: announcement.id || `ANN-${uuidv4().substring(0, 8).toUpperCase()}`
        })
        .select(`
          *,
          creator:users!created_by(
            id,
            name,
            email,
            role,
            company
          )
        `)
        .single();

      if (error) throw error;
      // Map snake_case to camelCase for frontend compatibility
      return {
        id: data.id,
        title: data.title,
        content: data.content,
        type: data.type,
        createdBy: data.created_by,
        creator: data.creator ? {
          id: data.creator.id,
          name: data.creator.name,
          email: data.creator.email,
          role: data.creator.role,
          company: data.creator.company
        } : null,
        isActive: data.is_active,
        createdAt: data.created_at,
        updatedAt: data.updated_at
      };
    },

    async update(id: string, updates: any) {
      const { data, error } = await supabase
        .from('announcements')
        .update(updates)
        .eq('id', id)
        .select(`
          *,
          creator:users!created_by(
            id,
            name,
            email,
            role,
            company
          )
        `)
        .single();

      if (error) throw error;
      // Map snake_case to camelCase for frontend compatibility
      return {
        id: data.id,
        title: data.title,
        content: data.content,
        type: data.type,
        createdBy: data.created_by,
        creator: data.creator ? {
          id: data.creator.id,
          name: data.creator.name,
          email: data.creator.email,
          role: data.creator.role,
          company: data.creator.company
        } : null,
        isActive: data.is_active,
        createdAt: data.created_at,
        updatedAt: data.updated_at
      };
    },

    async delete(id: string) {
      const { error } = await supabase
        .from('announcements')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
      return true;
    }
  },

  // Messages for real-time chat
  messages: {
    async getByShipment(shipmentId: string) {
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .eq('shipment_id', shipmentId)
        .order('created_at', { ascending: true });
      
      if (error) throw error;
      return data || [];
    },

    async create(message: {
      shipment_id: string;
      sender_id: string;
      sender_name: string;
      sender_role: 'customer' | 'staff' | 'admin' | 'system';
      content: string;
      attachments?: any;
    }) {
      // Set read status based on sender role - sender always reads their own message
      const readStatus = {
        read_by_staff: message.sender_role === 'staff' || message.sender_role === 'admin' || message.sender_role === 'system',
        read_by_customer: message.sender_role === 'customer',
        read_by_staff_at: (message.sender_role === 'staff' || message.sender_role === 'admin' || message.sender_role === 'system') ? new Date().toISOString() : null,
        read_by_customer_at: message.sender_role === 'customer' ? new Date().toISOString() : null,
        is_read: false // Only true when both parties have read it
      };

      console.log('Creating message with read status:', { ...message, ...readStatus });

      const { data, error } = await supabase
        .from('messages')
        .insert({ ...message, ...readStatus })
        .select()
        .single();

      if (error) {
        console.error('Error creating message:', error);
        throw error;
      }

      console.log('Message created successfully:', data);

      // No longer creating duplicate notifications here
      // Messages are now fetched directly from messages table in NotificationsContext

      return data;
    },

    async markAsRead(messageIds: string[], role: 'staff' | 'customer') {
      if (!messageIds || messageIds.length === 0) {
        console.log('No message IDs provided to mark as read');
        return true;
      }

      const updateData = role === 'staff' 
        ? { 
            read_by_staff: true, 
            read_by_staff_at: new Date().toISOString()
          }
        : { 
            read_by_customer: true, 
            read_by_customer_at: new Date().toISOString()
          };

      console.log(`Marking ${messageIds.length} messages as read for ${role}:`, updateData);
      console.log('Message IDs:', messageIds);

      try {
        const { data, error } = await supabase
          .from('messages')
          .update(updateData)
          .in('id', messageIds)
          .select();
        
        if (error) {
          console.error('Supabase update error:', error);
          throw error;
        }
        
        if (!data || data.length === 0) {
          console.warn('⚠️ Update returned no data - checking if RLS policies are working correctly');
          
          // Try to verify if the update actually worked by checking the current state
          const { data: checkData, error: checkError } = await supabase
            .from('messages')
            .select('id, read_by_staff, read_by_customer, read_by_staff_at, read_by_customer_at')
            .in('id', messageIds);
          
          if (checkError) {
            console.error('Error checking message status:', checkError);
          } else {
            console.log('Current message status after update attempt:', checkData);
            // Check if any were actually updated
            const updatedCount = checkData?.filter(msg => 
              role === 'staff' ? msg.read_by_staff : msg.read_by_customer
            ).length || 0;
            
            if (updatedCount > 0) {
              console.log(`✅ Despite no return data, ${updatedCount} messages appear to be marked as read`);
            } else {
              console.error('❌ Messages were NOT updated - RLS policy may still be blocking updates');
            }
          }
        } else {
          console.log(`✅ Successfully marked ${data.length} messages as read`);
        }
        
        return true;
      } catch (err) {
        console.error('Failed to mark messages as read:', err);
        // Don't throw - allow app to continue functioning
        return false;
      }
    },

    // Store active subscriptions
    activeSubscriptions: new Map(),

    // Subscribe to real-time changes
    subscribeToShipment(shipmentId: string, callback: (message: any) => void) {
      // Unsubscribe from existing subscription if exists
      if (this.activeSubscriptions.has(shipmentId)) {
        const existingSub = this.activeSubscriptions.get(shipmentId);
        if (existingSub) {
          supabase.removeChannel(existingSub);
        }
      }

      const subscription = supabase
        .channel(`messages:${shipmentId}`)
        .on('postgres_changes', {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `shipment_id=eq.${shipmentId}`
        }, (payload) => {
          callback(payload.new);
        })
        .subscribe();

      // Store the subscription
      this.activeSubscriptions.set(shipmentId, subscription);
      
      return subscription;
    },

    // Unsubscribe from real-time changes
    unsubscribe(shipmentId: string) {
      const subscription = this.activeSubscriptions.get(shipmentId);
      if (subscription) {
        supabase.removeChannel(subscription);
        this.activeSubscriptions.delete(shipmentId);
      }
    },

    // Get recent messages for a user (for notifications)
    async getRecentForUser(userId: string, userRole: 'user' | 'staff' | 'admin', since: string) {
      try {
        console.log('🔔 Getting recent messages for user:', { userId, userRole, since });

        // Get all shipments for this user
        // First, get messages without join (simpler query)
        let messagesQuery = supabase.from('messages').select('*');

        // For customers, get their shipments
        if (userRole === 'user') {
          // Get shipments where this user is the customer
          const { data: shipments } = await supabase
            .from('shipments')
            .select('id')
            .eq('customer_id', userId);

          if (shipments && shipments.length > 0) {
            const shipmentIds = shipments.map(s => s.id);
            messagesQuery = messagesQuery
              .in('shipment_id', shipmentIds)
              .neq('sender_id', userId)
              .gte('created_at', since)
              .order('created_at', { ascending: false });
          } else {
            return [];
          }
        } else {
          // For staff/admin, get all messages from customers
          messagesQuery = messagesQuery
            .eq('sender_role', 'customer')
            .gte('created_at', since)
            .order('created_at', { ascending: false });
        }

        const { data, error } = await messagesQuery;

        if (error) {
          console.error('🔔 Error fetching recent messages:', error);
          return [];
        }

        // Process messages to include shipment info
        // For now, just return the messages without warehouse info
        // We'll fetch that separately if needed
        const processedMessages = data || [];

        // If we have messages, fetch shipment info for them
        if (processedMessages.length > 0) {
          const shipmentIds = [...new Set(processedMessages.map((m: any) => m.shipment_id))];

          const { data: shipments } = await supabase
            .from('shipments')
            .select('id, destinations')
            .in('id', shipmentIds);

          // Add warehouse info to messages
          processedMessages.forEach((msg: any) => {
            const shipment = shipments?.find((s: any) => s.id === msg.shipment_id);
            if (shipment?.destinations) {
              const destinations = shipment.destinations;
              const warehouseCount = Object.keys(destinations).length;
              const warehouseNames = Object.keys(destinations).slice(0, 2).join(', ');
              msg.warehouse_info = warehouseCount > 2
                ? `${warehouseNames}, +${warehouseCount - 2} more`
                : warehouseNames;
            } else {
              msg.warehouse_info = '';
            }
          });
        }

        console.log('🔔 Found recent messages:', processedMessages.length);
        return processedMessages;
      } catch (error) {
        console.error('🔔 Error in getRecentForUser:', error);
        return [];
      }
    }
  },

  // System settings
  systemSettings: {
    async get(key: string) {
      const { data, error } = await supabase
        .from('system_settings')
        .select('*')
        .eq('key', key)
        .single();

      if (error && error.code !== 'PGRST116') { // PGRST116 = no rows
        throw error;
      }
      return data;
    },

    async update(key: string, value: string) {
      const { data, error } = await supabase
        .from('system_settings')
        .upsert({
          key,
          value,
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'key'
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    }
  },

  // User carton templates management
  userCartonTemplates: {
    async getByUserId(userId: string) {
      const { data, error } = await supabase
        .from('user_carton_templates')
        .select('*')
        .eq('user_id', userId)
        .order('nickname', { ascending: true });

      if (error) throw error;
      return data || [];
    },

    async create(template: {
      user_id: string;
      nickname: string;
      carton_weight: number;
      length: number;
      width: number;
      height: number;
      volumetric_weight: number;
    }) {
      const newTemplate = {
        id: `carton-template-${Date.now()}`,
        ...template,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      const { data, error } = await supabase
        .from('user_carton_templates')
        .insert([newTemplate])
        .select()
        .single();

      if (error) throw error;
      return data;
    },

    async update(id: string, updates: any) {
      const { data, error } = await supabase
        .from('user_carton_templates')
        .update({
          ...updates,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },

    async delete(id: string) {
      const { error } = await supabase
        .from('user_carton_templates')
        .delete()
        .eq('id', id);

      if (error) throw error;
      return { success: true };
    }
  },

  // Suppliers management - USER SPECIFIC
  suppliers: {
    async getByUserId(userId: string) {
      // IMPORTANT: Always filter by user_id to maintain privacy
      // This is critical since RLS might be relaxed for mock auth
      const { data, error } = await supabase
        .from('suppliers')
        .select('*')
        .eq('user_id', userId)  // Critical: ensures user privacy
        .order('name', { ascending: true });

      if (error) throw error;
      return data || [];
    },

    async getById(id: string) {
      const { data, error } = await supabase
        .from('suppliers')
        .select('*')
        .eq('id', id)
        .single();

      if (error && error.code !== 'PGRST116') {
        throw error;
      }
      return data;
    },

    async create(supplier: {
      user_id: string;
      name: string;
      address: string;
      city?: string;
      country?: string;
      contact_name?: string;
      contact_phone?: string;
      contact_email?: string;
      wechat_phone?: string;
    }) {
      const newSupplier = {
        id: `supplier-${Date.now()}`,
        ...supplier,
        country: supplier.country || 'China',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      const { data, error } = await supabase
        .from('suppliers')
        .insert([newSupplier])
        .select()
        .single();

      if (error) throw error;
      return data;
    },

    async update(id: string, updates: {
      name?: string;
      address?: string;
      city?: string;
      country?: string;
      contact_name?: string;
      contact_phone?: string;
      contact_email?: string;
      wechat_phone?: string;
    }) {
      const { data, error } = await supabase
        .from('suppliers')
        .update({
          ...updates,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },

    async delete(id: string) {
      const { error } = await supabase
        .from('suppliers')
        .delete()
        .eq('id', id);

      if (error) throw error;
      return { success: true };
    }
  },

  // Carton configurations management - USER SPECIFIC
  cartonConfigurations: {
    async getByUserId(userId: string) {
      console.log('Getting carton configurations for user:', userId);

      const { data, error } = await supabase
        .from('carton_configurations')
        .select('*')
        .eq('user_id', userId)
        .order('name', { ascending: true });

      if (error) {
        console.error('Error fetching carton configurations:', error);
        // Return empty array if table doesn't exist yet
        if (error.code === '42P01') {
          return [];
        }
        throw error;
      }

      console.log('Fetched carton configurations from database:', data);
      return data || [];
    },

    async create(config: {
      name: string;
      length: number;
      width: number;
      height: number;
      weight: number;
      user_id: string;
    }) {
      console.log('Creating carton configuration in database:', config);

      // First, ensure the user exists in the database
      const { data: existingUser } = await supabase
        .from('users')
        .select('id')
        .eq('id', config.user_id)
        .single();

      if (!existingUser) {
        // Try to get user from localStorage and create them
        const currentUser = JSON.parse(localStorage.getItem('currentUser') || '{}');
        if (currentUser && currentUser.id === config.user_id) {
          const { error: userError } = await supabase
            .from('users')
            .insert({
              id: currentUser.id,
              display_id: currentUser.display_id || currentUser.id,
              name: currentUser.name || 'Unknown User',
              email: currentUser.email || 'unknown@example.com',
              password_hash: 'mock_hash',
              company: currentUser.company || '',
              role: currentUser.role || 'user',
              created_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            });

          if (userError && userError.code !== '23505') { // Ignore duplicate key errors
            console.error('Failed to create user for carton config:', userError);
            throw new Error('User must exist before creating carton configurations');
          }
        }
      }

      const newConfig = {
        id: `carton-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        ...config,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      };

      const { data, error } = await supabase
        .from('carton_configurations')
        .insert([newConfig])
        .select()
        .single();

      if (error) {
        console.error('Error creating carton configuration:', error);
        console.error('Error details:', {
          code: error.code,
          message: error.message,
          details: error.details,
          hint: error.hint
        });
        throw error;
      }

      console.log('Created carton configuration:', data);
      return data;
    },

    async update(id: string, updates: Partial<{
      name: string;
      length: number;
      width: number;
      height: number;
      weight: number;
    }>) {
      const { data, error } = await supabase
        .from('carton_configurations')
        .update({
          ...updates,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select()
        .single();

      if (error) throw error;
      return data;
    },

    async delete(id: string) {
      const { error } = await supabase
        .from('carton_configurations')
        .delete()
        .eq('id', id);

      if (error) throw error;
      return { success: true };
    }
  }
};